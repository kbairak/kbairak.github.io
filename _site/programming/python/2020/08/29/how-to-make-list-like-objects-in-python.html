<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>How to properly make list-like objects in Python | kbairak’s blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="How to properly make list-like objects in Python" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this post we will be talking about how Python likes to deal with “list-like objects”. We will be diving into some quirks of Python that might seem a bit weird and, in the end, hopefully teach you how to build something that could actually be useful while avoiding common mistakes." />
<meta property="og:description" content="In this post we will be talking about how Python likes to deal with “list-like objects”. We will be diving into some quirks of Python that might seem a bit weird and, in the end, hopefully teach you how to build something that could actually be useful while avoiding common mistakes." />
<link rel="canonical" href="https://kbairak.github.io/programming/python/2020/08/29/how-to-make-list-like-objects-in-python.html" />
<meta property="og:url" content="https://kbairak.github.io/programming/python/2020/08/29/how-to-make-list-like-objects-in-python.html" />
<meta property="og:site_name" content="kbairak’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-08-29T15:00:00+03:00" />
<script type="application/ld+json">
{"dateModified":"2020-08-29T15:00:00+03:00","datePublished":"2020-08-29T15:00:00+03:00","description":"In this post we will be talking about how Python likes to deal with “list-like objects”. We will be diving into some quirks of Python that might seem a bit weird and, in the end, hopefully teach you how to build something that could actually be useful while avoiding common mistakes.","mainEntityOfPage":{"@type":"WebPage","@id":"https://kbairak.github.io/programming/python/2020/08/29/how-to-make-list-like-objects-in-python.html"},"url":"https://kbairak.github.io/programming/python/2020/08/29/how-to-make-list-like-objects-in-python.html","@type":"BlogPosting","headline":"How to properly make list-like objects in Python","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://kbairak.github.io/feed.xml" title="kbairak's blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">kbairak&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">How to properly make list-like objects in Python</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-08-29T15:00:00+03:00" itemprop="datePublished">Aug 29, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In this post we will be talking about how Python likes to deal with “list-like
objects”. We will be diving into some quirks of Python that might seem a bit
weird and, in the end, hopefully teach you how to build something that could
actually be useful while avoiding common mistakes.</p>

<h1 id="part-1-fake-lists">Part 1: Fake lists</h1>

<p>Lets start with this snippet.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FakeList</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"zero"</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"one"</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"two"</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"three"</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"four"</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"five"</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"six"</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">IndexError</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">FakeList</span><span class="p">()</span>
</code></pre></div></div>

<p>A lot of people will be familiar with this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="c1"># 'three'
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">__getitem__</code> is the method you override if you want your instances to respond
to the square bracket notation. Essentially <code class="language-plaintext highlighter-rouge">f[3]</code> is equivalent to
<code class="language-plaintext highlighter-rouge">f.__getitem__(3)</code>.</p>

<p>What you may not know, is this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="c1"># 0 zero
# 1 one
# 2 two
# 3 three
# 4 four
# 5 five
# 6 six
</span>
<span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c1"># ['zero', 'one', 'two', 'three', 'four', 'five', 'six']
</span></code></pre></div></div>

<p>or this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">'three'</span> <span class="ow">in</span> <span class="n">f</span>
<span class="c1"># True
</span><span class="s">'apple'</span> <span class="ow">in</span> <span class="n">f</span>
<span class="c1"># False
</span></code></pre></div></div>

<p>Before I explain what I <em>think</em> is going on, lets try to tweak the snippet to
see how it reacts:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> class FakeList:
     def __getitem__(self, index):
         if index == 0:
             return "zero"
         elif index == 1:
             return "one"
         elif index == 2:
             return "two"
         elif index == 3:
             return "three"
<span class="gd">-        elif index == 4:
-            return "four"
</span>         elif index == 5:
             return "five"
         elif index == 6:
             return "six"
         else:
             raise IndexError(index)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="n">FakeList</span><span class="p">()</span>
<span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</code></pre></div></div>

<p>Although this would be a reasonable outcome:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c1"># ['zero', 'one', 'two', 'three', 'five', 'six']  # wrong
</span></code></pre></div></div>

<p>It turns out that the actual result is this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c1"># ['zero', 'one', 'two', 'three']
</span></code></pre></div></div>

<p>Lets try another tweak now:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> class FakeList:
     def __getitem__(self, index):
         if index == 0:
             return "zero"
         elif index == 1:
             return "one"
         elif index == 2:
             return "two"
         elif index == 3:
             return "three"
         elif index == 4:
             return "four"
         elif index == 5:
             return "five"
         elif index == 6:
             return "six"
<span class="gd">-        else:
-            raise IndexError(index)
</span></code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="n">FakeList</span><span class="p">()</span>
<span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</code></pre></div></div>

<p>If you try to run this, it will get stuck and you will have to stop it with
ctrl-c. To see why this is the case, lets tweak some more:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="nb">input</span><span class="p">(</span><span class="s">"Press Enter to continue"</span><span class="p">)</span>

<span class="c1"># 0 zero
# Press Enter to continue
# 1 one
# Press Enter to continue
# 2 two
# Press Enter to continue
# 3 three
# Press Enter to continue
# 4 four
# Press Enter to continue
# 5 five
# Press Enter to continue
# 6 six
# Press Enter to continue
# 7 None
# Press Enter to continue
# 8 None
# Press Enter to continue
# 9 None
# Press Enter to continue
# 10 None
# Press Enter to continue
# 11 None
# Press Enter to continue
# ...
</span></code></pre></div></div>

<p>And our final tweak:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> class FakeList:
     def __getitem__(self, index):
         if index == 0:
             return "zero"
         elif index == 1:
             return "one"
         elif index == 2:
             return "two"
         elif index == 3:
<span class="gi">+            3 / 0
</span>             return "three"
         elif index == 4:
             return "four"
         elif index == 5:
             return "five"
         elif index == 6:
             return "six"
         else:
             raise IndexError(index)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="n">FakeList</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="c1"># 0 zero
# 1 one
# 2 two
# ZeroDivisionError: divison by zero
</span></code></pre></div></div>

<p>With all of this in mind, lets try to figure out what Python does when you try
to iterate over an object. The steps are, in order:</p>

<ol>
  <li>
    <p>See if object has an <code class="language-plaintext highlighter-rouge">__iter__</code> method. If it does, call it and <code class="language-plaintext highlighter-rouge">yield</code> the
results.</p>
  </li>
  <li>
    <p>See if the object has a <code class="language-plaintext highlighter-rouge">__next__</code> method. If it does, call it repeatedly,
<code class="language-plaintext highlighter-rouge">yield</code> each result until at some point it raises a <code class="language-plaintext highlighter-rouge">StopIteration</code>
exception.</p>

    <p>It would be reasonable to assume that Python would give up at this point,
but it looks like it has yet another trick up its sleeve:</p>
  </li>
  <li>
    <p>See if the object has a <code class="language-plaintext highlighter-rouge">__getitem__</code> method. If it does:</p>

    <ul>
      <li>Call it with <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">yield</code> the result</li>
      <li>Call it with <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">yield</code> the result</li>
      <li>Call it with <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">yield</code> the result</li>
      <li>
        <p>and so on</p>
      </li>
      <li>If at some point you get an <code class="language-plaintext highlighter-rouge">IndexError</code>, stop the iteration</li>
      <li>If at some point you get any other exception, raise it</li>
    </ul>
  </li>
</ol>

<p>This explains all our examples. When we removed the <code class="language-plaintext highlighter-rouge">elif index == 4</code> part, it
went straight to the <code class="language-plaintext highlighter-rouge">IndexError</code> and stopped the iteration. When we removed
the <code class="language-plaintext highlighter-rouge">raise IndexError(index)</code> part, it went to the end of the body of the
method, which in Python means that the method returns <code class="language-plaintext highlighter-rouge">None</code>; <code class="language-plaintext highlighter-rouge">None</code> is a
perfectly acceptable value for <code class="language-plaintext highlighter-rouge">__getitem__</code> to return, so the iteration went
on. When we injected a <code class="language-plaintext highlighter-rouge">3 / 0</code> somewhere, it raised a <code class="language-plaintext highlighter-rouge">ZeroDivisionError</code> in
the middle of the iteration.</p>

<p>Lets now revert to our first example, the “correct” one, and try throwing some
more curveballs at it:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c1"># TypeError: object of type 'FakeList' has no len()
</span>
<span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="c1"># TypeError: object of type 'FakeList' has no len()
</span></code></pre></div></div>

<p>To be honest, the first time I tried these, I expected <code class="language-plaintext highlighter-rouge">len()</code> to work. Python
would simply have to try an iteration and count how many steps it took to reach
an <code class="language-plaintext highlighter-rouge">IndexError</code>. But it doesn’t. It probably makes sense since iterable
sequences may also be infinite sequences and Python would get stuck. The fact
that <code class="language-plaintext highlighter-rouge">reversed()</code> doesn’t work wasn’t surprizing, especially since <code class="language-plaintext highlighter-rouge">len()</code>
didn’t work.  How would Python know where to start? In fact, Python complains
for the missing <code class="language-plaintext highlighter-rouge">len()</code> of <code class="language-plaintext highlighter-rouge">FakeList</code>, not <code class="language-plaintext highlighter-rouge">reversed()</code>. But it seems that we
can fix both problems by adding <code class="language-plaintext highlighter-rouge">len()</code> to our <code class="language-plaintext highlighter-rouge">FakeList</code>:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> class FakeList:
     def __getitem__(self, index):
         if index == 0:
             return "zero"
         elif index == 1:
             return "one"
         elif index == 2:
             return "two"
         elif index == 3:
             return "three"
         elif index == 4:
             return "four"
         elif index == 5:
             return "five"
         elif index == 6:
             return "six"
         else:
             raise IndexError(index)
 
<span class="gi">+    def __len__(self):
+        return 7
</span></code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="n">FakeList</span><span class="p">()</span>
<span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c1"># 7
</span>
<span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="c1"># ['six', 'five', 'four', 'three', 'two', 'one', 'zero']
</span></code></pre></div></div>

<p>So, to sum up. What can we do with our <code class="language-plaintext highlighter-rouge">FakeList</code> object?</p>

<ol>
  <li>We can use the square bracket notation (no surprises there):
<code class="language-plaintext highlighter-rouge">f[3] == "three"</code></li>
  <li>We can call <code class="language-plaintext highlighter-rouge">len()</code> on it (again, no surprises): <code class="language-plaintext highlighter-rouge">len(f) == 7</code></li>
  <li>We can iterate over it: <code class="language-plaintext highlighter-rouge">for n in f: print(n)</code>, <code class="language-plaintext highlighter-rouge">list(f)</code></li>
  <li>We can reverse it: <code class="language-plaintext highlighter-rouge">for n in reversed(f): print(n)</code>, <code class="language-plaintext highlighter-rouge">list(reversed(f))</code></li>
  <li>We can find things in it with <code class="language-plaintext highlighter-rouge">in</code>: <code class="language-plaintext highlighter-rouge">'three' in f == True</code></li>
</ol>

<p>So, our <code class="language-plaintext highlighter-rouge">FakeList</code> appears to behave like a list in almost all respects. But,
how can we be sure that we have covered all the bases? Are we missing
something? Is there a defined “interface” for “list-like objects” in Python?</p>

<h1 id="part-2-abstract-base-classes">Part 2: Abstract Base Classes</h1>

<p>Abstract Base Classes, or ABCs, are a feature of Python that is not all that
well known. There is some theory behind them, that they try to strike a balance
between “static typing”, which in Python it usually means using <code class="language-plaintext highlighter-rouge">isinstance</code> a
lot to determine if a value conforms with the type you are expecting, and “duck
typing”, which usually means “don’t check the types of any value; instead
interact with them as if they have the type you expect, and deal with the
exceptions that will be raised if they don’t conform to your expected type’s
interface”. ABCs introduce something that in the Python ecosystem is called
“Goose typing”.</p>

<p>Long story short, Abstract Base Classes allow you to call
<code class="language-plaintext highlighter-rouge">isinstance(obj, cls)</code> and have it return <code class="language-plaintext highlighter-rouge">True</code>, when in fact <code class="language-plaintext highlighter-rouge">obj</code> is <strong>not</strong>
an instance of <code class="language-plaintext highlighter-rouge">cls</code> or one of its subclasses. Lets see it in action:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">NotSized</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sized</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">NotSized</span><span class="p">(),</span> <span class="n">Sized</span><span class="p">)</span>
<span class="c1"># True
</span></code></pre></div></div>

<p>You can write your own ABCs, and the theory behind why they are needed and how
they work is interesting, but it is not what I want to talk about here.
Because, apart from defying <code class="language-plaintext highlighter-rouge">isinstance</code>, they also have some functionality
built in. If you visit the <a href="https://docs.python.org/3/library/collections.abc.html">documentation page of
<code class="language-plaintext highlighter-rouge">collections.abc</code></a>, you will see the following section:</p>

<table>
  <thead>
    <tr>
      <th>ABC</th>
      <th>Inherits from</th>
      <th>Abstract methods</th>
      <th>Mixin methods</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Sequence</code></td>
      <td><code class="language-plaintext highlighter-rouge">Reversible</code>, <code class="language-plaintext highlighter-rouge">Collection</code></td>
      <td><code class="language-plaintext highlighter-rouge">__getitem__</code>, <code class="language-plaintext highlighter-rouge">__len__</code></td>
      <td><code class="language-plaintext highlighter-rouge">__contains__</code>, <code class="language-plaintext highlighter-rouge">__iter__</code>, <code class="language-plaintext highlighter-rouge">__reversed__</code>, <code class="language-plaintext highlighter-rouge">index</code>, <code class="language-plaintext highlighter-rouge">count</code></td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
  </tbody>
</table>

<p>This tells us the following: If your class subclasses <code class="language-plaintext highlighter-rouge">Sequence</code> and defines
the <code class="language-plaintext highlighter-rouge">__getitem__</code> and <code class="language-plaintext highlighter-rouge">__len__</code> methods, then:</p>

<ol>
  <li>calling <code class="language-plaintext highlighter-rouge">isinstance(obj, Sequence)</code> will return <code class="language-plaintext highlighter-rouge">True</code> and</li>
  <li>they will also have the other 5 methods: <code class="language-plaintext highlighter-rouge">__contains__</code>, <code class="language-plaintext highlighter-rouge">__iter__</code>,
<code class="language-plaintext highlighter-rouge">__reversed__</code>, <code class="language-plaintext highlighter-rouge">index</code> and <code class="language-plaintext highlighter-rouge">count</code></li>
</ol>

<p><em>(You can verify the second statement by checking out
<a href="https://github.com/python/cpython/blob/3.8/Lib/_collections_abc.py#L856">the source code of <code class="language-plaintext highlighter-rouge">Sequence</code></a>; it’s neither big nor
complicated)</em></p>

<p>The first statement is not really surprising, but it is important because it
turns out that <code class="language-plaintext highlighter-rouge">isinstance(obj, Sequence) == True</code> is the “official” way of
saying that <code class="language-plaintext highlighter-rouge">obj</code> is a readable list-like object in Python.</p>

<p>What is interesting here is that, even without subclassing from <code class="language-plaintext highlighter-rouge">Sequence</code>,
Python already gave <code class="language-plaintext highlighter-rouge">__contains__</code>, <code class="language-plaintext highlighter-rouge">__iter__</code> and <code class="language-plaintext highlighter-rouge">__reversed__</code> to our
<code class="language-plaintext highlighter-rouge">FakeList</code> class from <em>Part 1</em>. Lets put the last two mixin methods to the
test:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="s">'two'</span><span class="p">)</span>
<span class="c1"># AttributeError: 'FakeList' object has no attribute 'index'
</span>
<span class="n">f</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">'two'</span><span class="p">)</span>
<span class="c1"># AttributeError: 'FakeList' object has no attribute 'count'
</span></code></pre></div></div>

<p>We can fix this by subclassing <code class="language-plaintext highlighter-rouge">FakeList</code> from <code class="language-plaintext highlighter-rouge">Sequence</code></p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+from collections.abc import Sequence
</span> 
<span class="gd">-class FakeList:
</span><span class="gi">+class FakeList(Sequence):
</span>     def __getitem__(self, index):
 ...
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="s">'two'</span><span class="p">)</span>
<span class="c1"># 2
</span>
<span class="n">f</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">'two'</span><span class="p">)</span>
<span class="c1"># 1
</span></code></pre></div></div>

<p>So the bottom line of all this is:</p>

<blockquote>
  <p>If you want to make something that can be “officially” considered a readable
list-like object in Python, make it subclass <code class="language-plaintext highlighter-rouge">Sequence</code> and implement at
least the <code class="language-plaintext highlighter-rouge">__getitem__</code> and <code class="language-plaintext highlighter-rouge">__len__</code> methods</p>
</blockquote>

<h1 id="part-3-chainable-methods">Part 3: Chainable methods</h1>

<p>We are going to shift topics away from list-like objects now. Don’t worry,
everything will come together in the end. Lets make another useless class.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Counter</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">f"&lt;Counter: </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">_count</span><span class="si">}</span><span class="s">&gt;"</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="n">c</span><span class="p">.</span><span class="n">increment</span><span class="p">()</span>
<span class="n">c</span><span class="p">.</span><span class="n">increment</span><span class="p">()</span>
<span class="n">c</span><span class="p">.</span><span class="n">increment</span><span class="p">()</span>
<span class="n">c</span>
<span class="c1"># &lt;Counter: 3&gt;
</span></code></pre></div></div>

<p>Nothing surprising here.</p>

<p>It would be nice if we could make the <code class="language-plaintext highlighter-rouge">.increment</code> calls chainable, ie, if we
could do:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">().</span><span class="n">increment</span><span class="p">().</span><span class="n">increment</span><span class="p">().</span><span class="n">increment</span><span class="p">()</span>
<span class="n">c</span>
<span class="c1"># &lt;Counter: 3&gt;
</span></code></pre></div></div>

<p>The easiest way to accomplish this is to have <code class="language-plaintext highlighter-rouge">.increment()</code> return the
<code class="language-plaintext highlighter-rouge">Counter</code> object itself:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> class Counter:
     def __init__(self):
         self._count = 0

     def increment(self):
         self._count += 1
<span class="gi">+        return self
</span>
     def __repr__(self):
         return f"&lt;Counter: {self._count}&gt;"
</code></pre></div></div>

<p>However, this is not advisable. Here is an <a href="https://mail.python.org/pipermail/python-dev/2003-October/038855.html">email</a> from Guido van
Rossum (the creator of Python) from 2003:</p>

<blockquote>
  <p>I’d like to explain once more why I’m so adamant that sort() shouldn’t return
‘self’.</p>

  <p>This comes from a coding style (popular in various other languages, I believe
especially Lisp revels in it) where a series of side effects on a single
object can be chained like this:</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x.compress().chop(y).sort(z)
</code></pre></div>  </div>

  <p>which would be the same as</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x.compress()
x.chop(y)
x.sort(z)
</code></pre></div>  </div>

  <p>I find the chaining form a threat to readability; it requires that the reader
must be intimately familiar with each of the methods.  The second form makes
it clear that each of these calls acts on the same object, and so even if you
don’t know the class and its methods very well, you can understand that the
second and third call are applied to x (and that all calls are made for their
side-effects), and not to something else.</p>

  <p>I’d like to reserve chaining for operations that return new values, like
string processing operations:</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>y = x.rstrip("\n").split(":").lower()
</code></pre></div>  </div>

  <p>There are a few standard library modules that encourage chaining of
side-effect calls (pstat comes to mind).  There shouldn’t be any new ones;
pstat slipped through my filter when it was weak.</p>

  <p>–Guido van Rossum (home page: http://www.python.org/~guido/)</p>
</blockquote>

<p>Here is how I interpret this. If someone reads this snippet:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">obj</span><span class="p">.</span><span class="n">do_something</span><span class="p">()</span>
</code></pre></div></div>

<p>they will assume that <code class="language-plaintext highlighter-rouge">.do_something()</code>:</p>

<ul>
  <li>mutates <code class="language-plaintext highlighter-rouge">obj</code> in some way, and/or</li>
  <li>has an interesting side-effect</li>
  <li>probably returns <code class="language-plaintext highlighter-rouge">None</code></li>
</ul>

<p>When they read this snippet:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">obj2</span> <span class="o">=</span> <span class="n">obj1</span><span class="p">.</span><span class="n">do_something</span><span class="p">()</span>
</code></pre></div></div>

<p>they will assume that:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.do_something()</code> does not change <code class="language-plaintext highlighter-rouge">obj1</code> in any way</li>
  <li><code class="language-plaintext highlighter-rouge">obj2</code> will have a new value, either a different type (eg a result status) or
a slightly mutated copy of <code class="language-plaintext highlighter-rouge">obj1</code></li>
</ul>

<p>These assumptions break down when methods <code class="language-plaintext highlighter-rouge">return self</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c1</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">().</span><span class="n">increment</span><span class="p">()</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">c1</span><span class="p">.</span><span class="n">increment</span><span class="p">()</span>
<span class="n">c1</span><span class="p">,</span> <span class="n">c2</span>
<span class="c1"># (&lt;Counter: 2&gt;, &lt;Counter: 2&gt;)
</span>
<span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span>
<span class="c1"># True
</span></code></pre></div></div>

<p>Someone not familiar with the implementation of <code class="language-plaintext highlighter-rouge">Counter</code> would assume that
<code class="language-plaintext highlighter-rouge">c1</code> would have the value <code class="language-plaintext highlighter-rouge">1</code>.</p>

<p>How do we <em>fix</em> this? My suggestion is: make the class’s initializer accept any
optional arguments required to fully describe the instance’s state. Then,
chainable methods will return a new instance with the appropriate, slightly
changed, state.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> class Counter:
<span class="gd">-    def __init__(self):
-        self._count = 0
</span><span class="gi">+    def __init__(self, count=0):
+        self._count = count
</span>
     def increment(self):
<span class="gd">-        self._count += 1
-        return self
</span><span class="gi">+        return Counter(self._count + 1)
</span>
     def __repr__(self):
         return f"&lt;Counter: {self._count}&gt;"
</code></pre></div></div>

<p>Lets try it out:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c1</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">().</span><span class="n">increment</span><span class="p">()</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">c1</span><span class="p">.</span><span class="n">increment</span><span class="p">()</span>
<span class="n">c1</span><span class="p">,</span> <span class="n">c2</span>
<span class="c1"># (&lt;Counter: 1&gt;, &lt;Counter: 2&gt;)
</span>
<span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span>
<span class="c1"># False
</span></code></pre></div></div>

<p>It might be a little better if we also do this:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> class Counter:
     def __init__(self, count=0):
         self._count = count

     def increment(self):
<span class="gd">-        return Counter(self._count + 1)
</span><span class="gi">+        return self.__class__(self._count + 1)
</span>
     def __repr__(self):
         return f"&lt;Counter: {self._count}&gt;"
</code></pre></div></div>

<p>so that <code class="language-plaintext highlighter-rouge">.increment()</code> works for subclasses of <code class="language-plaintext highlighter-rouge">Counter</code>.</p>

<p>We essentially made the <code class="language-plaintext highlighter-rouge">Counter</code> objects <strong>immutable</strong>, unless someone changes
the <em>“private”</em> <code class="language-plaintext highlighter-rouge">_count</code> attribute by hand.</p>

<h1 id="part-4-bringing-everything-together">Part 4: Bringing everything together</h1>

<p>It’s now time to build something actually useful. Lets consume an API and
access the responses like lists. We are going to use the
<a href="https://transifex.github.io/openapi/">Transifex API (v3)</a>. Lets start with a snippet:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">requests</span>

<span class="k">class</span> <span class="nc">TxCollection</span><span class="p">:</span>
    <span class="n">HOST</span> <span class="o">=</span> <span class="s">"https://rest.api.transifex.com"</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">HOST</span> <span class="o">+</span> <span class="n">url</span><span class="p">,</span>
            <span class="n">headers</span><span class="o">=</span><span class="p">{</span><span class="s">'Content-Type'</span><span class="p">:</span> <span class="s">"application/vnd.api+json"</span><span class="p">,</span>
                     <span class="s">'Authorization'</span><span class="p">:</span> <span class="s">f"Bearer </span><span class="si">{</span><span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'API_TOKEN'</span><span class="p">]</span><span class="si">}</span><span class="s">"</span><span class="p">},</span>
        <span class="p">)</span>
        <span class="n">response</span><span class="p">.</span><span class="n">raise_for_status</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="n">json</span><span class="p">()[</span><span class="s">'data'</span><span class="p">]</span>

<span class="n">organizations</span> <span class="o">=</span> <span class="n">TxCollection</span><span class="p">(</span><span class="s">"/organizations"</span><span class="p">)</span>
<span class="n">organizations</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">'attributes'</span><span class="p">][</span><span class="s">'name'</span><span class="p">]</span>
<span class="c1"># 'kb_org'
</span></code></pre></div></div>

<p>Now lets make this behave like a list:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">-import os
</span><span class="gi">+import os, reprlib, collections
</span> import requests
 
<span class="gd">-class TxCollection:
</span><span class="gi">+class TxCollection(collections.abc.Sequence):
</span>     HOST = "https://rest.api.transifex.com"
 
     def __init__(self, url):
         response = requests.get(
             self.HOST + url,
             headers={'Content-Type': "application/vnd.api+json",
                      'Authorization': f"Bearer {os.environ['API_TOKEN']}"},
         )
         response.raise_for_status()
<span class="gd">-        self.data = response.json()['data']
</span><span class="gi">+        self._data = response.json()['data']
</span> 
<span class="gi">+    def __getitem__(self, index):
+        return self._data[index]
+
+    def __len__(self):
+        return len(self._data)
+
+    def __repr__(self):
+        result = ", ".join((reprlib.repr(item['id']) for item in self))
+        result = f"&lt;TxCollection ({len(self)}): {result}&gt;"
+        return result
</span></code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">organizations</span> <span class="o">=</span> <span class="n">TxCollection</span><span class="p">(</span><span class="s">"/organizations"</span><span class="p">)</span>
<span class="n">organizations</span>
<span class="c1"># &lt;TxCollection (3): 'o:diegobz', 'o:kb_org', 'o:transifex'&gt;
</span>
<span class="n">organizations</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="c1"># {'id': 'o:transifex',
#  'type': 'organizations',
#  'attributes': {
#   'name': 'Transifex',
#   'slug': 'transifex',
#   'logo_url': 'https://txc-assets-775662142440-prod.s3.amazonaws.com/mugshots/435381b2e0.jpg',
#   'private': False},
#  'links': {'self': 'https://rest.api.transifex.com/organizations/o:transifex'}}
</span></code></pre></div></div>

<p>What is interesting here is that we <em>know</em> that our class is a legitimate
readable list-like object because we fulfilled the requirements we set in <em>Part
2</em>: we subclassed from <code class="language-plaintext highlighter-rouge">collections.abc.Sequence</code> and implemented the
<code class="language-plaintext highlighter-rouge">__getitem__</code> and <code class="language-plaintext highlighter-rouge">__len__</code> methods.</p>

<p>Now, if you are familiar with Django querysets, you will know that you can
apply filters to them and that their evaluation is applied
<a href="https://docs.djangoproject.com/en/3.1/topics/db/queries/#querysets-are-lazy">lazily</a>, ie evaluated on demand, after the filters
have been set. Lets try to apply this logic here, first by making our
collections lazy:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> import os, reprlib, collections
 import requests
 
 class TxCollection(collections.abc.Sequence):
     HOST = "https://rest.api.transifex.com"
 
     def __init__(self, url):
         self._url = url
<span class="gi">+        self._data = None
</span> 
<span class="gi">+    def _evaluate(self):
+        if self._data is not None:
+            return
</span>         response = requests.get(
             self.HOST + self._url,
             headers={'Content-Type': "application/vnd.api+json",
                      'Authorization': f"Bearer {os.environ['API_TOKEN']}"},
         )
         response.raise_for_status()
         self._data = response.json()['data']
 
     def __getitem__(self, index):
<span class="gi">+        self._evaluate()
</span>         return self._data[index]
 
     def __len__(self):
<span class="gi">+        self._evaluate()
</span>         return len(self._data)
 
     def __repr__(self):
         result = ", ".join((reprlib.repr(item['id']) for item in self))
         result = f"&lt;TxCollection ({len(self)}): {result}&gt;"
         return result
</code></pre></div></div>

<p>Our <em>lazy</em> evaluation:</p>

<ol>
  <li>Will only be triggered when we try to access the collection like a list</li>
  <li>Will abort early if the collection has already been evaluated</li>
</ol>

<p>To drive point 1 home, I will point out that our <code class="language-plaintext highlighter-rouge">__repr__</code> method does <strong>not</strong>
explicitly trigger an evaluation, but triggers it nevertheless. The
<code class="language-plaintext highlighter-rouge">for item in self</code> part in its first line will start an iteration, which will
call <code class="language-plaintext highlighter-rouge">__getitem__</code> (as we saw in <em>Part 1</em>), which will trigger the evaluation.
Even if it didn’t, the <code class="language-plaintext highlighter-rouge">len(self)</code> part in the second line would also trigger
the evaluation.</p>

<p>Playing with metaprogramming, which in this context means making things behave
like things that they are not, can be tricky, dangerous and cause bugs, as
anyone who has played with <code class="language-plaintext highlighter-rouge">__getattr__</code> and ran into <code class="language-plaintext highlighter-rouge">RecursionError</code>s can
attest to. This is the beauty of the conclusion from <em>Part 2</em>: we want to make
<code class="language-plaintext highlighter-rouge">TxCollection</code> behave like a list and we know <strong>exactly</strong> which parts of the
code trigger that behaviour: <code class="language-plaintext highlighter-rouge">__getitem__</code> and <code class="language-plaintext highlighter-rouge">__len__</code>. That’s the <strong>only</strong>
parts we need to add our custom evaluation to in order to be 100% confident
that <code class="language-plaintext highlighter-rouge">TxCollection</code> will properly behave like a readable list.</p>

<p>Now lets apply filtering. We will intentionally do it the <em>wrong</em> way, by
returning <code class="language-plaintext highlighter-rouge">self</code>, so that we can see the flaws outlined in <em>Part 3</em> in the
context of this example. Then we will fix it.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> class TxCollection(collections.abc.Sequence):
     HOST = "https://rest.api.transifex.com"

     def __init__(self, url):
         self._url = url
<span class="gi">+        self._params = {}
</span>
         self._data = None

     def _evaluate(self):
         if self._data is not None:
             return
         response = requests.get(
             self.HOST + self._url,
<span class="gi">+            params=self._params,
</span>             headers={'Content-Type': "application/vnd.api+json",
                      'Authorization': f"Bearer {os.environ['API_TOKEN']}"},
         )
         response.raise_for_status()
         self._data = response.json()['data']
 
<span class="gi">+    def filter(self, **filters):
+        self._params.update({f'filter[{key}]': value
+                             for key, value in filters.items()})
+        return self
</span>
     # def __getitem__, __len__, __repr__
</code></pre></div></div>

<p>Lets take this out for a spin:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TxCollection</span><span class="p">(</span><span class="s">"/resource_translations"</span><span class="p">).</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">resource</span><span class="o">=</span><span class="s">"o:kb_org:p:kb1:r:fileless"</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="s">"l:el"</span><span class="p">)</span>
<span class="c1"># &lt;TxCollection (3): 'o:kb_org:p:k...72e4fdb0:l:el',
#                    'o:kb_org:p:k...e877d7ee:l:el',
#                    'o:kb_org:p:k...ed953f8f:l:el'&gt;
</span></code></pre></div></div>

<p><em>(Note: There are some Transifex-API-v3-specific things here, like how
filtering is applied and what the IDs of the objects look like, that you don’t
have to worry about. If you are interested, you can check out <a href="https://transifex.github.io/openapi/">the
documentation</a>)</em></p>

<p>And now lets demonstrate the flaw we outlined in <em>Part 3</em></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c1</span> <span class="o">=</span> <span class="n">TxCollection</span><span class="p">(</span><span class="s">"/resource_translations"</span><span class="p">).</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">resource</span><span class="o">=</span><span class="s">"o:kb_org:p:kb1:r:fileless"</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="s">"l:el"</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">c1</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">translated</span><span class="o">=</span><span class="s">"true"</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">),</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span>
<span class="c1"># (1, 1, True)
</span></code></pre></div></div>

<p>We know from our previous run that <code class="language-plaintext highlighter-rouge">c1</code> should have a size of 3, but it got
overwritten when we applied <code class="language-plaintext highlighter-rouge">.filter()</code> to it. Also,</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c1</span> <span class="o">=</span> <span class="n">TxCollection</span><span class="p">(</span><span class="s">"/resource_translations"</span><span class="p">).</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">resource</span><span class="o">=</span><span class="s">"o:kb_org:p:kb1:r:fileless"</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="s">"l:el"</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">c1</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">translated</span><span class="o">=</span><span class="s">"true"</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">),</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span>
<span class="c1"># (3, 3, True)
</span></code></pre></div></div>

<p>We forced an evaluation <strong>before</strong> we applied the second filter (with
<code class="language-plaintext highlighter-rouge">_ = list(c1)</code>), so the second filter was ignored, in both <code class="language-plaintext highlighter-rouge">c1</code> and <code class="language-plaintext highlighter-rouge">c2</code>.</p>

<p>To fix this, we will do the same thing we did in <em>Part 3</em>: we will add optional
arguments to the initializer that describe the whole state of a <code class="language-plaintext highlighter-rouge">TxCollection</code>
object and have <code class="language-plaintext highlighter-rouge">.filter()</code> return a slightly mutated copy of <code class="language-plaintext highlighter-rouge">self</code>.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> class TxCollection(collections.abc.Sequence):
     HOST = "https://rest.api.transifex.com"
 
<span class="gd">-    def __init__(self, url):
</span><span class="gi">+    def __init__(self, url, params=None):
+        if params is None:
+            params = {}
</span>
         self._url = url
<span class="gd">-        self._params = {}
</span><span class="gi">+        self._params = params
</span>
         self._data = None

     # def _evaluate
 
<span class="gd">-    def filter(self, **filters):
-        self._params.update({f'filter[{key}]': value
-                             for key, value in filters.items()})
-        return self
</span><span class="gi">+    def filter(self, **filters):
+        params = dict(self._params)  # Make a copy
+        params.update({f'filter[{key}]': value
+                       for key, value in filters.items()})
+        return self.__class__(self._url, params)
</span>
     # def __getitem__, __len__, __repr__
</code></pre></div></div>

<p><em>(Note: we didn’t set <code class="language-plaintext highlighter-rouge">params={}</code> as the default value in the initializer
because <a href="https://github.com/satwikkansal/wtfpython#-beware-of-default-mutable-arguments">you shouldn’t use mutable default arguments</a>)</em></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c1</span> <span class="o">=</span> <span class="n">TxCollection</span><span class="p">(</span><span class="s">"/resource_translations"</span><span class="p">).</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">resource</span><span class="o">=</span><span class="s">"o:kb_org:p:kb1:r:fileless"</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="s">"l:el"</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">c1</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">translated</span><span class="o">=</span><span class="s">"true"</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">),</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span>
<span class="c1"># (3, 1, False)
</span></code></pre></div></div>

<p>Works like a charm!</p>

<p>We concluded <em>Part 3</em> by saying that the class we made creates immutable
objects, which is why it is safe to use chainable methods on them. What is
interesting here is that <code class="language-plaintext highlighter-rouge">TxCollection</code> objects are <strong>not</strong> immutable. So, how
do we ensure that implementing chainable methods is safe? The answer is that
the state of a <code class="language-plaintext highlighter-rouge">TxCollection</code> consists of two parts:</p>

<ul>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">_url</code> and <code class="language-plaintext highlighter-rouge">_params</code> attributes that <strong>are</strong> immutable.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">_data</code> attribute which is dynamic. <strong>But</strong>:</p>

    <ol>
      <li>
        <p>it will only be evaluated <strong>once</strong> and</p>
      </li>
      <li>
        <p>it has a <strong>deterministic</strong> relationship with the immutable parts. The
<strong>only</strong> way for <code class="language-plaintext highlighter-rouge">_data</code> to be evaluated differently is to change <code class="language-plaintext highlighter-rouge">_url</code>
and <code class="language-plaintext highlighter-rouge">_params</code>, which can only happen if we make a mutated copy of the
original object via <code class="language-plaintext highlighter-rouge">.filter()</code></p>
      </li>
    </ol>
  </li>
</ul>

<h1 id="conclusion">Conclusion</h1>

<p>I hope this has been interesting. You can write powerful and expressive code
with what is explained here, hopefully without introducing bugs.</p>


  </div><a class="u-url" href="/programming/python/2020/08/29/how-to-make-list-like-objects-in-python.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">kbairak&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">kbairak&#39;s blog</li><li><a class="u-email" href="mailto:ikijob@gmail.com">ikijob@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/kbairak"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">kbairak</span></a></li><li><a href="https://www.twitter.com/kbairak"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">kbairak</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Mostly programming tips and tutorials, mostly in Python. But who knows? I may rumble about other things as well.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
